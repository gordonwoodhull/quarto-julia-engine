// Generated by dts-bundle-generator v9.5.1

/**
 * Minimal type definitions for CLI commands
 */
export interface Command {
	command(name: string, description?: string): Command;
	description(description: string): Command;
	action(fn: (...args: any[]) => void | Promise<void>): Command;
	arguments(args: string): Command;
	option(flags: string, description: string, options?: any): Command;
}
/**
 * Core text manipulation types for Quarto
 */
/**
 * Represents a range within a string
 */
interface Range$1 {
	start: number;
	end: number;
}
/**
 * A string with source mapping information
 */
export interface MappedString {
	/**
	 * The text content
	 */
	readonly value: string;
	/**
	 * Optional filename where the content originated
	 */
	readonly fileName?: string;
	/**
	 * Maps positions in this string back to positions in the original source
	 * @param index Position in the current string
	 * @param closest Whether to find the closest mapping if exact is not available
	 */
	readonly map: (index: number, closest?: boolean) => StringMapResult;
}
/**
 * Result of mapping a position in a mapped string
 */
export type StringMapResult = {
	/**
	 * Position in the original source
	 */
	index: number;
	/**
	 * Reference to the original mapped string
	 */
	originalString: MappedString;
} | undefined;
/**
 * String that may be mapped or unmapped
 */
export type EitherString = string | MappedString;
/**
 * Basic metadata types used across Quarto
 */
/**
 * Generic metadata key-value store
 */
export type Metadata = {
	[key: string]: unknown;
};
/**
 * Format identifier information
 */
export interface FormatIdentifier {
	"base-format"?: string;
	"target-format"?: string;
	"display-name"?: string;
	"extension-name"?: string;
}
/**
 * Format language/localization strings
 */
export interface FormatLanguage {
	[key: string]: string | undefined;
}
/**
 * Complete Format type for engine interfaces
 */
export interface Format {
	/**
	 * Format identifier
	 */
	identifier: FormatIdentifier;
	/**
	 * Format language/localization strings
	 */
	language: FormatLanguage;
	/**
	 * Document metadata
	 */
	metadata: Metadata;
	/**
	 * Format rendering options
	 */
	render?: Record<string, unknown>;
	/**
	 * Format execution options
	 */
	execute: Record<string, unknown>;
	/**
	 * Format pandoc options
	 */
	pandoc: {
		to?: string;
		[key: string]: unknown;
	};
}
/**
 * External engine interfaces for Quarto
 */
/**
 * Represents an external engine specified in a project
 */
export interface ExternalEngine {
	/**
	 * Path to the engine implementation
	 */
	path: string;
}
/**
 * Jupyter notebook kernelspec
 */
export interface JupyterKernelspec {
	name: string;
	language: string;
	display_name: string;
	path?: string;
}
/**
 * Jupyter notebook cell metadata
 */
export interface JupyterCellMetadata {
	[key: string]: unknown;
}
/**
 * Jupyter notebook output
 */
export interface JupyterOutput {
	output_type: string;
	metadata?: {
		[mimetype: string]: Record<string, unknown>;
	};
	execution_count?: number;
	[key: string]: unknown;
}
/**
 * Jupyter notebook cell
 */
export interface JupyterCell {
	cell_type: "markdown" | "code" | "raw";
	metadata: JupyterCellMetadata;
	source: string | string[];
	id?: string;
	execution_count?: number | null;
	outputs?: JupyterOutput[];
	attachments?: {
		[filename: string]: {
			[mimetype: string]: string | string[];
		};
	};
}
/**
 * Jupyter notebook structure
 */
export interface JupyterNotebook {
	cells: JupyterCell[];
	metadata: {
		kernelspec: JupyterKernelspec;
		[key: string]: unknown;
	};
	nbformat: number;
	nbformat_minor: number;
}
/**
 * Asset paths for Jupyter notebook output
 */
export interface JupyterNotebookAssetPaths {
	base_dir: string;
	files_dir: string;
	figures_dir: string;
	supporting_dir: string;
}
/**
 * Format execution options
 */
export interface FormatExecute {
	[key: string]: unknown;
}
/**
 * Format render options
 */
export interface FormatRender {
	[key: string]: unknown;
}
/**
 * Format pandoc options
 */
export interface FormatPandoc {
	to?: string;
	[key: string]: unknown;
}
/**
 * Jupyter widget state information
 */
export interface JupyterWidgetsState {
	state: Record<string, unknown>;
	version_major: number;
	version_minor: number;
}
/**
 * Widget dependencies from Jupyter notebook
 */
export interface JupyterWidgetDependencies {
	jsWidgets: boolean;
	jupyterWidgets: boolean;
	htmlLibraries: string[];
	widgetsState?: JupyterWidgetsState;
}
/**
 * Cell output with markdown
 */
export interface JupyterCellOutput {
	id: string;
	markdown: string;
	metadata: Record<string, unknown>;
	options: Record<string, unknown>;
}
/**
 * Options for converting Jupyter notebook to markdown
 */
export interface JupyterToMarkdownOptions {
	executeOptions: ExecuteOptions;
	language: string;
	assets: JupyterNotebookAssetPaths;
	execute: FormatExecute;
	keepHidden?: boolean;
	toHtml: boolean;
	toLatex: boolean;
	toMarkdown: boolean;
	toIpynb: boolean;
	toPresentation: boolean;
	figFormat?: string;
	figDpi?: number;
	figPos?: string;
	preserveCellMetadata?: boolean;
	preserveCodeCellYaml?: boolean;
	outputPrefix?: string;
	fixups?: string | unknown[];
}
/**
 * Result of converting Jupyter notebook to markdown
 */
export interface JupyterToMarkdownResult {
	cellOutputs: JupyterCellOutput[];
	notebookOutputs?: {
		prefix?: string;
		suffix?: string;
	};
	dependencies?: JupyterWidgetDependencies;
	htmlPreserve?: Record<string, string>;
	pandoc?: Record<string, unknown>;
}
/**
 * Global Quarto API interface
 */
export interface QuartoAPI {
	/**
	 * Markdown processing utilities using regex patterns
	 */
	markdownRegex: {
		/**
		 * Extract and parse YAML frontmatter from markdown
		 *
		 * @param markdown - Markdown content with YAML frontmatter
		 * @returns Parsed metadata object
		 */
		extractYaml: (markdown: string) => Metadata;
		/**
		 * Split markdown into components (YAML, heading, content)
		 *
		 * @param markdown - Markdown content
		 * @returns Partitioned markdown with yaml, heading, and content sections
		 */
		partition: (markdown: string) => PartitionedMarkdown;
		/**
		 * Extract programming languages from code blocks
		 *
		 * @param markdown - Markdown content to analyze
		 * @returns Set of language identifiers found in fenced code blocks
		 */
		getLanguages: (markdown: string) => Set<string>;
	};
	/**
	 * MappedString utilities for source location tracking
	 */
	mappedString: {
		/**
		 * Create a mapped string from plain text
		 *
		 * @param text - Text content
		 * @param fileName - Optional filename for source tracking
		 * @returns MappedString with identity mapping
		 */
		fromString: (text: string, fileName?: string) => MappedString;
		/**
		 * Read a file and create a mapped string
		 *
		 * @param path - Path to the file to read
		 * @returns MappedString with file content and source information
		 */
		fromFile: (path: string) => MappedString;
		/**
		 * Normalize newlines while preserving source mapping
		 *
		 * @param markdown - MappedString to normalize
		 * @returns MappedString with \r\n converted to \n
		 */
		normalizeNewlines: (markdown: MappedString) => MappedString;
		/**
		 * Split a MappedString into lines
		 *
		 * @param str - MappedString to split
		 * @param keepNewLines - Whether to keep newline characters (default: false)
		 * @returns Array of MappedStrings, one per line
		 */
		splitLines: (str: MappedString, keepNewLines?: boolean) => MappedString[];
		/**
		 * Convert character offset to line/column coordinates
		 *
		 * @param str - MappedString to query
		 * @param offset - Character offset to convert
		 * @returns Line and column numbers (1-indexed)
		 */
		indexToLineCol: (str: MappedString, offset: number) => {
			line: number;
			column: number;
		};
	};
	/**
	 * Jupyter notebook integration utilities
	 */
	jupyter: {
		/**
		 * Create asset paths for Jupyter notebook output
		 *
		 * @param input - Input file path
		 * @param to - Output format (optional)
		 * @returns Asset paths for files, figures, and supporting directories
		 */
		assets: (input: string, to?: string) => JupyterNotebookAssetPaths;
		/**
		 * Convert a Jupyter notebook to markdown
		 *
		 * @param nb - Jupyter notebook to convert
		 * @param options - Conversion options
		 * @returns Converted markdown with cell outputs and dependencies
		 */
		toMarkdown: (nb: JupyterNotebook, options: JupyterToMarkdownOptions) => Promise<JupyterToMarkdownResult>;
		/**
		 * Convert result dependencies to Pandoc includes
		 *
		 * @param tempDir - Temporary directory for includes
		 * @param dependencies - Widget dependencies from execution result
		 * @returns Pandoc includes structure
		 */
		resultIncludes: (tempDir: string, dependencies?: JupyterWidgetDependencies) => PandocIncludes;
		/**
		 * Extract engine dependencies from result dependencies
		 *
		 * @param dependencies - Widget dependencies from execution result
		 * @returns Array of widget dependencies or undefined
		 */
		resultEngineDependencies: (dependencies?: JupyterWidgetDependencies) => Array<JupyterWidgetDependencies> | undefined;
		/**
		 * Check if a file is a Jupyter percent script
		 *
		 * @param file - File path to check
		 * @param extensions - Optional array of extensions to check (default: ['.py', '.jl', '.r'])
		 * @returns True if file is a Jupyter percent script
		 */
		isPercentScript: (file: string, extensions?: string[]) => boolean;
		/**
		 * Convert a Jupyter percent script to markdown
		 *
		 * @param file - Path to the percent script file
		 * @returns Converted markdown content
		 */
		percentScriptToMarkdown: (file: string) => string;
	};
	/**
	 * Format detection utilities
	 */
	format: {
		/**
		 * Check if format is HTML compatible
		 *
		 * @param format - Format to check
		 * @returns True if format is HTML compatible
		 */
		isHtmlCompatible: (format: Format) => boolean;
		/**
		 * Check if format is Jupyter notebook output
		 *
		 * @param format - Format pandoc options to check
		 * @returns True if format is ipynb
		 */
		isIpynbOutput: (format: FormatPandoc) => boolean;
		/**
		 * Check if format is LaTeX output
		 *
		 * @param format - Format pandoc options to check
		 * @returns True if format is LaTeX (pdf, latex, or beamer)
		 */
		isLatexOutput: (format: FormatPandoc) => boolean;
		/**
		 * Check if format is markdown output
		 *
		 * @param format - Format to check
		 * @param flavors - Optional array of markdown flavors to check
		 * @returns True if format is markdown
		 */
		isMarkdownOutput: (format: Format, flavors?: string[]) => boolean;
		/**
		 * Check if format is presentation output
		 *
		 * @param format - Format pandoc options to check
		 * @returns True if format is a presentation format
		 */
		isPresentationOutput: (format: FormatPandoc) => boolean;
		/**
		 * Check if format is HTML dashboard output
		 *
		 * @param format - Optional format string to check
		 * @returns True if format is a dashboard
		 */
		isHtmlDashboardOutput: (format?: string) => boolean;
	};
	/**
	 * Path manipulation utilities
	 */
	path: {
		/**
		 * Convert path to absolute form with platform-specific handling
		 *
		 * Handles URL to file path conversion, makes relative paths absolute,
		 * normalizes the path, and uppercases Windows drive letters.
		 *
		 * @param path - Path string or URL to make absolute
		 * @returns Absolute, normalized path with Windows-specific fixes
		 */
		absolute: (path: string | URL) => string;
		/**
		 * Convert path to use forward slashes
		 *
		 * @param path - Path with backslashes or forward slashes
		 * @returns Path with only forward slashes
		 */
		toForwardSlashes: (path: string) => string;
		/**
		 * Get platform-specific runtime directory for Quarto
		 *
		 * Returns the appropriate runtime/state directory based on platform:
		 * - macOS: ~/Library/Caches/quarto/{subdir}
		 * - Windows: %LOCALAPPDATA%/quarto/{subdir}
		 * - Linux: $XDG_RUNTIME_DIR or ~/.local/share/quarto/{subdir}
		 *
		 * Automatically creates the directory if it doesn't exist.
		 *
		 * @param subdir - Optional subdirectory within the runtime directory
		 * @returns Absolute path to the runtime directory
		 */
		runtime: (subdir?: string) => string;
		/**
		 * Get path to a Quarto resource file
		 *
		 * Returns the path to bundled resource files in Quarto's share directory.
		 * Can accept multiple path segments that will be joined.
		 *
		 * @param parts - Path segments to join (e.g., "julia", "script.jl")
		 * @returns Absolute path to the resource file
		 */
		resource: (...parts: string[]) => string;
	};
	/**
	 * System and environment detection utilities
	 */
	system: {
		/**
		 * Check if running in an interactive session
		 *
		 * Detects if Quarto is running in an interactive environment such as:
		 * - RStudio IDE
		 * - VS Code output channel
		 * - Interactive terminal (TTY)
		 *
		 * @returns True if running in an interactive environment
		 */
		isInteractiveSession: () => boolean;
		/**
		 * Check if running in a CI/CD environment
		 *
		 * Detects if Quarto is running in a continuous integration environment by checking
		 * for common CI environment variables across 40+ CI/CD platforms including:
		 * - GitHub Actions
		 * - GitLab CI
		 * - Jenkins
		 * - CircleCI
		 * - Travis CI
		 * - And many more
		 *
		 * @returns True if running in a CI/CD environment
		 */
		runningInCI: () => boolean;
	};
}
/**
 * Global Quarto API object
 */
export declare const quartoAPI: QuartoAPI;
/**
 * Execution target (filename and context)
 */
export interface ExecutionTarget {
	/** Original source file */
	source: string;
	/** Input file after preprocessing */
	input: string;
	/** Markdown content */
	markdown: MappedString;
	/** Document metadata */
	metadata: Metadata;
	/** Optional target-specific data */
	data?: unknown;
}
/**
 * Valid Pandoc include locations
 */
export type PandocIncludeLocation = "include-in-header" | "include-before-body" | "include-after-body";
/**
 * Pandoc includes for headers, body, etc.
 * Mapped type that allows any of the valid include locations
 */
export type PandocIncludes = {
	[K in PandocIncludeLocation]?: string[];
};
/**
 * Options for execution
 */
export interface ExecuteOptions {
	/** The execution target */
	target: ExecutionTarget;
	/** Format to render to */
	format: Format;
	/** Directory for resources */
	resourceDir: string;
	/** Directory for temporary files */
	tempDir: string;
	/** Whether to include dependencies */
	dependencies: boolean;
	/** Project directory if applicable */
	projectDir?: string;
	/** Library directory */
	libDir?: string;
	/** Current working directory */
	cwd: string;
	/** Parameters passed to document */
	params?: {
		[key: string]: unknown;
	};
	/** Whether to suppress output */
	quiet?: boolean;
	/** Whether execution is for preview server */
	previewServer?: boolean;
	/** List of languages handled by cell language handlers */
	handledLanguages: string[];
	/** Project context */
	project: EngineProjectContext;
}
/**
 * Result of execution
 */
export interface ExecuteResult {
	/** Resulting markdown content */
	markdown: string;
	/** Supporting files */
	supporting: string[];
	/** Filter scripts */
	filters: string[];
	/** Updated metadata */
	metadata?: Metadata;
	/** Pandoc options */
	pandoc?: Record<string, unknown>;
	/** Pandoc includes */
	includes?: PandocIncludes;
	/** Engine name */
	engine?: string;
	/** Engine-specific dependencies */
	engineDependencies?: Record<string, Array<unknown>>;
	/** Content to preserve during processing */
	preserve?: Record<string, string>;
	/** Whether post-processing is required */
	postProcess?: boolean;
	/** Additional resource files */
	resourceFiles?: string[];
}
/**
 * Options for retrieving dependencies
 */
export interface DependenciesOptions {
	/** The execution target */
	target: ExecutionTarget;
	/** Format to render to */
	format: Format;
	/** Output file path */
	output: string;
	/** Directory for resources */
	resourceDir: string;
	/** Directory for temporary files */
	tempDir: string;
	/** Project directory if applicable */
	projectDir?: string;
	/** Library directory */
	libDir?: string;
	/** Dependencies to include */
	dependencies?: Array<unknown>;
	/** Whether to suppress output */
	quiet?: boolean;
}
/**
 * Result of retrieving dependencies
 */
export interface DependenciesResult {
	/** Pandoc includes */
	includes: PandocIncludes;
}
/**
 * Options for post-processing
 */
export interface PostProcessOptions {
	/** The execution engine */
	engine: ExecutionEngineInstance;
	/** The execution target */
	target: ExecutionTarget;
	/** Format to render to */
	format: Format;
	/** Output file path */
	output: string;
	/** Directory for temporary files */
	tempDir: string;
	/** Project directory if applicable */
	projectDir?: string;
	/** Content to preserve during processing */
	preserve?: Record<string, string>;
	/** Whether to suppress output */
	quiet?: boolean;
}
/**
 * Options for running the engine
 */
export interface RunOptions {
	/** Input file path */
	input: string;
	/** Whether to render */
	render: boolean;
	/** Whether to open in browser */
	browser: boolean;
	/** Directory for temporary files */
	tempDir: string;
	/** Whether to reload */
	reload?: boolean;
	/** Target format */
	format?: string;
	/** Project directory if applicable */
	projectDir?: string;
	/** Port for server */
	port?: number;
	/** Host for server */
	host?: string;
	/** Whether to suppress output */
	quiet?: boolean;
	/** Callback when ready */
	onReady?: () => Promise<void>;
}
/**
 * Render flags (extends pandoc flags)
 */
export interface RenderFlags {
	outputDir?: string;
	siteUrl?: string;
	executeDir?: string;
	execute?: boolean;
	executeCache?: true | false | "refresh";
	executeDaemon?: number;
	executeDaemonRestart?: boolean;
	executeDebug?: boolean;
	useFreezer?: boolean;
	metadata?: {
		[key: string]: unknown;
	};
	pandocMetadata?: {
		[key: string]: unknown;
	};
	params?: {
		[key: string]: unknown;
	};
	paramsFile?: string;
	clean?: boolean;
	debug?: boolean;
	quiet?: boolean;
	version?: string;
	to?: string;
	output?: string;
	[key: string]: unknown;
}
/**
 * Render options (simplified)
 * Note: The internal Quarto version includes a 'services' field with
 * RenderServices, which has been omitted as it requires internal dependencies.
 */
export interface RenderOptions {
	flags?: RenderFlags;
	pandocArgs?: string[];
	progress?: boolean;
	useFreezer?: boolean;
	devServerReload?: boolean;
	previewServer?: boolean;
	setProjectDir?: boolean;
	forceClean?: boolean;
	echo?: boolean;
	warning?: boolean;
	quietPandoc?: boolean;
}
/**
 * Result file from rendering
 */
export interface RenderResultFile {
	/** Input file path */
	input: string;
	/** Markdown content */
	markdown: string;
	/** Format used for rendering */
	format: Format;
	/** Output file path */
	file: string;
	/** Whether this is a transient file */
	isTransient?: boolean;
	/** Supporting files generated */
	supporting?: string[];
	/** Resource files */
	resourceFiles: string[];
	/** Whether this is a supplemental file */
	supplemental?: boolean;
}
/**
 * A partitioned markdown document
 */
export interface PartitionedMarkdown {
	/** YAML frontmatter as parsed metadata */
	yaml?: Metadata;
	/** Text of the first heading */
	headingText?: string;
	/** Attributes of the first heading */
	headingAttr?: {
		id: string;
		classes: string[];
		keyvalue: Array<[
			string,
			string
		]>;
	};
	/** Whether the document contains references */
	containsRefs: boolean;
	/** Complete markdown content */
	markdown: string;
	/** Markdown without YAML frontmatter */
	srcMarkdownNoYaml: string;
}
/**
 * Interface for execution engine discovery
 * Responsible for the static aspects of engine discovery (not requiring project context)
 */
export interface ExecutionEngineDiscovery {
	/**
	 * Initialize the engine with the Quarto API (optional)
	 * May be called multiple times but always with the same QuartoAPI object.
	 * Engines should store the reference to use throughout their lifecycle.
	 *
	 * @param quarto - The Quarto API for accessing utilities
	 */
	init?: (quarto: QuartoAPI) => void;
	/**
	 * Name of the engine
	 */
	name: string;
	/**
	 * Default extension for files using this engine
	 */
	defaultExt: string;
	/**
	 * Generate default YAML for this engine
	 */
	defaultYaml: (kernel?: string) => string[];
	/**
	 * Generate default content for this engine
	 */
	defaultContent: (kernel?: string) => string[];
	/**
	 * List of file extensions this engine supports
	 */
	validExtensions: () => string[];
	/**
	 * Whether this engine can handle the given file
	 *
	 * @param file - The file path to check
	 * @param ext - The file extension
	 * @returns True if this engine can handle the file
	 */
	claimsFile: (file: string, ext: string) => boolean;
	/**
	 * Whether this engine can handle the given language
	 */
	claimsLanguage: (language: string) => boolean;
	/**
	 * Whether this engine supports freezing
	 */
	canFreeze: boolean;
	/**
	 * Whether this engine generates figures
	 */
	generatesFigures: boolean;
	/**
	 * Directories to ignore during processing (optional)
	 */
	ignoreDirs?: () => string[] | undefined;
	/**
	 * Populate engine-specific CLI commands (optional)
	 * Called at module initialization to register commands like 'quarto enginename status'
	 *
	 * @param command - The CLI command to populate with subcommands
	 */
	populateCommand?: (command: Command) => void;
	/**
	 * Launch a dynamic execution engine with project context
	 * This is called when the engine is needed for execution
	 *
	 * @param context The restricted project context
	 * @returns ExecutionEngineInstance that can execute documents
	 */
	launch: (context: EngineProjectContext) => ExecutionEngineInstance;
}
/**
 * Interface for a launched execution engine
 * This represents an engine that has been instantiated with a project context
 * and is ready to execute documents
 */
export interface ExecutionEngineInstance {
	/**
	 * Name of the engine
	 */
	name: string;
	/**
	 * Whether this engine supports freezing
	 */
	canFreeze: boolean;
	/**
	 * Get the markdown content for a file
	 */
	markdownForFile(file: string): Promise<MappedString>;
	/**
	 * Create an execution target for the given file
	 */
	target: (file: string, quiet?: boolean, markdown?: MappedString) => Promise<ExecutionTarget | undefined>;
	/**
	 * Get a partitioned view of the markdown
	 */
	partitionedMarkdown: (file: string, format?: Format) => Promise<PartitionedMarkdown>;
	/**
	 * Filter the format based on engine requirements
	 */
	filterFormat?: (source: string, options: RenderOptions, format: Format) => Format;
	/**
	 * Execute the target
	 */
	execute: (options: ExecuteOptions) => Promise<ExecuteResult>;
	/**
	 * Handle skipped execution targets
	 */
	executeTargetSkipped?: (target: ExecutionTarget, format: Format) => void;
	/**
	 * Get dependencies for the target
	 */
	dependencies: (options: DependenciesOptions) => Promise<DependenciesResult>;
	/**
	 * Post-process the execution result
	 */
	postprocess: (options: PostProcessOptions) => Promise<void>;
	/**
	 * Whether this engine can keep source for this target
	 */
	canKeepSource?: (target: ExecutionTarget) => boolean;
	/**
	 * Get a list of intermediate files generated by this engine
	 */
	intermediateFiles?: (input: string) => string[] | undefined;
	/**
	 * Run the engine (for interactivity)
	 */
	run?: (options: RunOptions) => Promise<void>;
	/**
	 * Post-render processing
	 */
	postRender?: (file: RenderResultFile) => Promise<void>;
}
/**
 * Information about a file being processed
 */
export interface FileInformation {
	/**
	 * Full markdown content after expanding includes
	 */
	fullMarkdown?: MappedString;
	/**
	 * Map of file inclusions
	 */
	includeMap?: {
		source: string;
		target: string;
	}[];
	/**
	 * The launched execution engine for this file
	 */
	engine?: ExecutionEngineInstance;
	/**
	 * The execution target for this file
	 */
	target?: ExecutionTarget;
	/**
	 * Document metadata
	 */
	metadata?: Metadata;
}
/**
 * A restricted version of ProjectContext that only exposes
 * functionality needed by execution engines.
 */
export interface EngineProjectContext {
	/**
	 * Base directory of the project
	 */
	dir: string;
	/**
	 * Flag indicating if project consists of a single file
	 */
	isSingleFile: boolean;
	/**
	 * Config object containing project configuration
	 * Used primarily for config?.engines access
	 */
	config?: {
		engines?: (string | ExternalEngine)[];
		project?: {
			outputDir?: string;
		};
	};
	/**
	 * For file information cache management
	 * Used for the transient notebook tracking in Jupyter
	 */
	fileInformationCache: Map<string, FileInformation>;
	/**
	 * Get the output directory for the project
	 *
	 * @returns Path to output directory
	 */
	getOutputDirectory: () => string;
	/**
	 * Resolves full markdown content for a file, including expanding includes
	 *
	 * @param engine - The execution engine
	 * @param file - Path to the file
	 * @param markdown - Optional existing markdown content
	 * @param force - Whether to force re-resolution even if cached
	 * @returns Promise resolving to mapped markdown string
	 */
	resolveFullMarkdownForFile: (engine: ExecutionEngineInstance | undefined, file: string, markdown?: MappedString, force?: boolean) => Promise<MappedString>;
}

export {
	Range$1 as Range,
};

export {};
